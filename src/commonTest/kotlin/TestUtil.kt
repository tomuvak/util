package com.tomuvak.util

import com.tomuvak.testing.gc.tryToAchieveByForcingGc
import kotlinx.coroutines.coroutineScope
import kotlin.test.assertFalse
import kotlin.test.assertNotNull
import kotlin.test.assertSame
import kotlin.test.assertTrue

/**
 * Can be used as a "proper object" (that can be the target of a [WeakReference]) when wanting a [value] of a type [T]
 * which cannot be weak-referenced.
 */
class Wrapper<T>(val value: T)

/**
 * Retrieve the next element from the receiver iterator [this] – and discard it. Useful for tests relying on garbage
 * collection, as using this function – as opposed to calling `.next()` directly – helps them avoid creating a (hidden)
 * strong reference to the element (which would foil garbage collection).
 */
internal fun <T> Iterator<T>.dismissNext() { next() }

/**
 * Returns a pair consisting of a sequence of [numElements] objects, each generated by calling [elementGenerator] with
 * the respective object's zero-based index, and a list of weak references to these objects. The list of weak references
 * is available immediately, but the objects themselves are yielded by the sequence one by one, with each object
 * forgotten once it's been yielded. In particular, the sequence can only be iterated once.
 */
internal fun <T : Any> generateSequenceAndWeakReferences(
    numElements: Int,
    elementGenerator: (Int) -> T
): Pair<Sequence<T>, List<WeakReference<T>>> {
    val elements = MutableList<T?>(numElements, elementGenerator)
    val references = elements.map { WeakReference(it!!) }
    return sequence { repeat(numElements) { index ->
        yield(elements[index]!!.also {
            elements[index] = null
            // This verification is an added precaution to make sure this function behaves as it should
            assertSame(it, assertNotNull(references[index].targetOrNull))
        })
    } }.constrainOnce() to references
}

internal suspend fun WeakReference<Any>.assertTargetOnlyReclaimableAfter(block: () -> Unit) {
    assertTargetNotReclaimable()
    block()
    assertTargetReclaimable()
}
internal suspend fun WeakReference<Any>.assertTargetNotReclaimable() = assertFalse(targetIsReclaimable())
internal suspend fun WeakReference<Any>.assertTargetReclaimable() = assertTrue(targetIsReclaimable())
private suspend fun WeakReference<Any>.targetIsReclaimable(): Boolean =
    coroutineScope { tryToAchieveByForcingGc { targetOrNull == null } }
