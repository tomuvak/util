package com.tomuvak.util

import com.tomuvak.testing.gc.tryToAchieveByForcingGc
import kotlinx.coroutines.coroutineScope
import kotlin.test.assertFalse
import kotlin.test.assertNotNull
import kotlin.test.assertSame
import kotlin.test.assertTrue

/**
 * Can be used as a "proper object" (that can be the target of a [WeakReference]) when wanting a [value] of a type [T]
 * which cannot be weak-referenced.
 */
class Wrapper<T>(val value: T)

/**
 * Retrieve the next element from the receiver iterator [this] – and discard it. Useful for tests relying on garbage
 * collection, as using this function – as opposed to calling `.next()` directly – helps them avoid creating a (hidden)
 * strong reference to the element (which would foil garbage collection).
 */
internal fun <T> Iterator<T>.dismissNext() { next() }

/**
 * Returns a pair consisting of a sequence of [numElements] objects, each generated by calling [elementGenerator] with
 * the respective object's zero-based index, and a list of weak references to these objects. Note that while the list of
 * weak references is exposed to calling code as immutable, it in fact gets populated by the references one by one as
 * the sequence is being iterated. The sequence can only be iterated once.
 */
internal fun <T : Any> generateSequenceAndWeakReferences(
    numElements: Int,
    elementGenerator: (Int) -> T
): Pair<Sequence<T>, List<WeakReference<T>>> {
    val references = mutableListOf<WeakReference<T>>()
    return Pair(
        sequence {
            repeat(numElements) { this.yield(elementGenerator(it).let { it to WeakReference(it) }) }
        }.map { (element, reference) ->
            assertSame(element, assertNotNull(reference.targetOrNull))
            references.add(reference)
            element
        }.constrainOnce(),
        references
    )
}

internal suspend fun WeakReference<Any>.assertTargetOnlyReclaimableAfter(block: () -> Unit) {
    assertTargetNotReclaimable()
    block()
    assertTargetReclaimable()
}
internal suspend fun WeakReference<Any>.assertTargetNotReclaimable() = assertFalse(targetIsReclaimable())
internal suspend fun WeakReference<Any>.assertTargetReclaimable() = assertTrue(targetIsReclaimable())
private suspend fun WeakReference<Any>.targetIsReclaimable(): Boolean =
    coroutineScope { tryToAchieveByForcingGc { targetOrNull == null } }
